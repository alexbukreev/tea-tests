# Платформа дегустации чая — Технический план (MVP, 3 спринта)

## 0. Обзор

- Домен: коллективные дегустации чая.
- Фронтенд: React + Vite + shadcn/ui.
- Бэкенд: Node.js (Express или лёгкий NestJS).
- База данных: PostgreSQL.
- Аутентификация: через Telegram, доступ к вебу по токенизированным ссылкам.
- Инфраструктура:
  - Dev: локальный Postgres в Docker, фронт и бэк запускаются нативно.
  - Prod: одно Docker‑приложение (API + статический фронтенд) на хостинге + управляемый PostgreSQL.

Работа делится на три спринта по две недели. Этот документ описывает целевую архитектуру и технический объём работ по спринтам.

---

## 1. Архитектура

### 1.1. Компоненты

- **Frontend‑приложение**
  - React + Vite.
  - UI‑кит: shadcn/ui.
  - Работает с REST API.
  - Основные сценарии:
    - форма оценок с лучевой диаграммой;
    - просмотр результата участника;
    - минимальный админ‑интерфейс.

- **Backend API**
  - Node.js‑приложение (Express или NestJS).
  - Ответственность:
    - обработка вебхуков/запросов от Telegram‑бота;
    - регистрация и идентификация пользователей по Telegram;
    - генерация и разрешение auth‑ссылок;
    - CRUD для дегустаций, образцов чая, оценок;
    - агрегации для отчётов.

- **База данных**
  - PostgreSQL 16/18.
  - В продакшене — управляемый инстанс.
  - В разработке — контейнер в Docker.

- **Telegram‑бот**
  - Бот на базе `node-telegram-bot-api`, Telegraf или аналогичной библиотеки.
  - Общается только с backend API; вся бизнес‑логика на бэке.

- **Деплой**
  - Dockerfile для бэкенда (отдаёт собранный фронтенд как статику).
  - docker-compose:
    - `docker-compose.dev.yml` — локальная разработка (только БД).
    - `docker-compose.yml` — продакшен (приложение; БД — отдельный управляемый сервис).
  - CI/CD или автодеплой с Git‑репозитория на платформе хостинга.

---

## 2. Модель данных (MVP)

### 2.1. Таблицы

Минимальная концептуальная схема:

- **users**
  - `id` (UUID / serial PK)
  - `telegram_id` (bigint, уникальный)
  - `telegram_username` (text, nullable)
  - `telegram_full_name` (text)
  - `is_admin` (boolean, default false)
  - `created_at` (timestamp)

- **tastings**
  - `id` (UUID PK)
  - `title` (text)
  - `description` (text, nullable)
  - `scheduled_at` (timestamp, nullable)
  - `created_at` (timestamp)
  - `created_by` (FK → users.id, nullable)

- **tea_samples**
  - `id` (UUID PK)
  - `tasting_id` (FK → tastings.id)
  - `name` (text)
  - `notes` (text, nullable)
  - `order_index` (int) — порядок в дегустации

- **rating_dimensions**
  - `id` (UUID PK)
  - `tasting_id` (FK → tastings.id)
  - `code` (text) — например, `aroma`, `sweetness`
  - `label` (text) — человекочитаемое имя параметра
  - `min_value` (int, default 0)
  - `max_value` (int, default 10)

- **ratings**
  - `id` (UUID PK)
  - `user_id` (FK → users.id)
  - `tea_sample_id` (FK → tea_samples.id)
  - `created_at` (timestamp)
  - `data` (jsonb) — словарь: код параметра → значение (int)

- **auth_links**
  - `id` (UUID или случайный токен PK)
  - `user_id` (FK → users.id)
  - `purpose` (enum: `rating_page`, `result_page`, `admin_panel`, ...)
  - `context` (jsonb) — например, `{ "tasting_id": "...", "tea_sample_id": "..." }`
  - `expires_at` (timestamp)
  - `used_at` (timestamp, nullable)

Такая схема удобна для BI (особенно `ratings.data` с кодами параметров) и достаточно гибкая для будущих изменений.

---

## 3. Аутентификация и пользователи

### 3.1. Регистрация пользователя через Telegram

- Бот получает `/start` или любую команду.
- Бот отправляет POST на бэкенд:

  `POST /api/telegram/register`

  ```json
  {
    "telegram_id": 123456789,
    "username": "user",
    "full_name": "Tea Lover"
  }
  ```

- Логика бэкенда:
  - ищет пользователя по `telegram_id`;
  - если нет — создаёт;
  - обновляет username/full_name при необходимости;
  - возвращает `{ "status": "ok" }`.

### 3.2. Auth‑ссылки (одноразовые / краткоживущие)

- Эндпоинт бэкенда:

  `POST /api/auth/link`

  Пример тела (для страницы оценок):

  ```json
  {
    "telegram_id": 123456789,
    "purpose": "rating_page",
    "context": {
      "tasting_id": "UUID",
      "tea_sample_id": "UUID"
    }
  }
  ```

- Бэкенд:
  - находит пользователя по `telegram_id`;
  - создаёт запись в `auth_links` с `expires_at` (например, +30 минут);
  - возвращает URL вида `https://app.example/rate?token=<auth_link_id>`.

- Бот отправляет эту ссылку пользователю.

### 3.3. Разрешение auth‑ссылки

- Фронтенд:
  - читает `token` из query‑строки;
  - вызывает `GET /api/auth/resolve?token=<token>`.

- Бэкенд:
  - проверяет токен:
    - существует,
    - не истёк,
    - при необходимости — что `purpose` соответствует ожидаемому типу;
  - опционально выставляет `used_at` (если нужна строгая одноразовость);
  - возвращает:

  ```json
  {
    "user": {
      "id": "UUID",
      "name": "Tea Lover"
    },
    "purpose": "rating_page",
    "context": {
      "tasting_id": "UUID",
      "tea_sample_id": "UUID"
    }
  }
  ```

- Фронтенд:
  - сохраняет минимальное состояние сессии (userId, tastingId, teaSampleId) в памяти / session storage;
  - использует их для дальнейших запросов к API.

### 3.4. Доступ администратора

- Флаг `users.is_admin = true` помечает админов.
- Сценарий для админа:
  - админ отправляет в бота `/admin`;
  - бот запрашивает auth‑ссылку с `purpose = "admin_panel"`;
  - бэкенд проверяет, что пользователь является админом, создаёт ссылку;
  - админ открывает `https://app.example/admin?token=...`;
  - фронтенд вызывает `/api/auth/resolve` и проверяет `purpose === "admin_panel"`.

---

## 4. Спринты (техническая разбивка)

### Спринт 1 — Базовый бэкенд, БД, регистрация в Telegram, первичный деплой

**Цели:**

- Настроить структуру репозитория, базовый бэкенд, схему БД, интеграцию с Telegram и начальный деплой в Docker.

**Задачи:**

1. **Репозиторий и инструменты**
   - Создать монорепо или два репо (`frontend`, `backend`) — решить отдельно.
   - Настроить TypeScript для бэкенда (желательно).
   - Настроить базовый линтинг/форматирование.

2. **Каркас бэкенда**
   - Приложение на Express или NestJS.
   - Базовые роуты:
     - `GET /health` — проверка живости.
   - Загрузчик конфигурации (env‑переменные для DB URL, Telegram token и т.п.).

3. **База данных**
   - Выбрать ORM/инструмент миграций (Prisma / Knex / TypeORM).
   - Реализовать первую миграцию:
     - `users`,
     - `tastings`,
     - `tea_samples`.

4. **Интеграция с Telegram**
   - Создать бота и получить токен.
   - Реализовать эндпоинт `/api/telegram/register`.
   - Реализовать простой сценарий бота:
     - `/start` → запрос на `/api/telegram/register`.

5. **Инфраструктура для разработки**
   - `docker-compose.dev.yml`:
     - сервис `db` (Postgres).
   - Подключение бэкенда к `postgres://...@localhost:5432/tea_dev`.

6. **Продакшн‑инфраструктура (первая итерация)**
   - Dockerfile для бэкенда (сборка + запуск).
   - `docker-compose.yml` для прод‑сервиса приложения (один контейнер `app`).
   - Подключение к управляемому Postgres через `DATABASE_URL`.
   - Деплой на хостинг‑платформу, проверка `/health`.

**Результаты:**

- Рабочий бэкенд с БД и регистрацией пользователей через Telegram.
- Развёрнутое приложение (API + заглушка фронта).
- Техническая документация по env‑переменным, подключению БД и настройке бота.

---

### Спринт 2 — Дегустации, оценки, UI с лучевой диаграммой

**Цели:**

- Реализовать полный поток оценок: дегустации, образцы, параметры, оценки.
- Реализовать auth‑ссылки и веб‑страницу оценок с лучевой диаграммой.

**Задачи:**

1. **Расширение БД**
   - Добавить таблицы:
     - `rating_dimensions`,
     - `ratings`,
     - `auth_links`.
   - Написать миграции.

2. **API бэкенда**
   - CRUD‑эндпоинты (пока админские):
     - `POST /api/tastings`
     - `POST /api/tastings/:id/samples`
     - `POST /api/tastings/:id/dimensions`
   - Эндпоинты auth‑ссылок:
     - `POST /api/auth/link`
     - `GET /api/auth/resolve`
   - Эндпоинт для оценок:
     - `POST /api/ratings` — создание/обновление оценки пользователя по образцу.

3. **Telegram → ссылка на оценку**
   - Логика бота:
     - выбор дегустации,
     - запрос ссылки для оценки определённого образца,
     - отправка пользователю.

4. **Фронтенд — страница оценок**
   - Настройка Vite + shadcn/ui.
   - Имплементация страницы:
     - читает `token` из URL;
     - вызывает `/api/auth/resolve`;
     - получает контекст дегустации (название образца, список параметров);
     - отображает элементы ввода (слайдеры/инпуты) для каждого параметра;
     - отображает лучевую диаграмму (Recharts или Chart.js), связанной с текущими значениями;
     - отправляет оценки через `POST /api/ratings`.

5. **UX и тестирование**
   - Проверка потока end‑to‑end на тестовой дегустации с несколькими пользователями.
   - Исправление очевидных проблем по удобству.

**Результаты:**

- Завершённый поток оценок от Telegram до веб‑интерфейса и обратно к БД.
- Пользователи могут выставлять оценки образцам чая; данные сохраняются.
- Лучевая диаграмма работает на десктопе и мобильных устройствах.

---

### Спринт 3 — Отчёты для участников, админ‑панель, подготовка аналитики

**Цели:**

- Дать участникам отчёты (профиль + сравнение с группой).
- Реализовать минимальную админ‑панель для управления дегустациями и экспорта данных.
- Подготовить БД к подключению BI‑инструментов (DataLens).

**Задачи:**

1. **Агрегации и аналитические эндпоинты**
   - Эндпоинты:
     - `GET /api/tastings/:id/summary`
       - средние значения по параметрам и образцам;
     - `GET /api/users/:id/tastings/:tastingId/profile`
       - оценки пользователя + средние по группе.
   - Логика:
     - вычисление базового текстового профиля пользователя по его предпочтениям.

2. **Страница отчёта участника**
   - Frontend‑маршрут для страницы результата.
   - Аутентификация через токен (`purpose = "result_page"`).
   - UI:
     - лучевая диаграмма: пользователь vs группа;
     - текстовое описание профиля.

3. **Интеграция бота для результатов**
   - После завершения дегустации (пока вручную админом) триггер отправки результатов.
   - Бэкенд генерирует auth‑ссылки с `purpose = "result_page"`.
   - Бот рассылает ссылки участникам.

4. **Админ‑панель (MVP)**
   - Маршрут `/admin` на фронте.
   - Аутентификация через токен (`purpose = "admin_panel"`, проверка `user.is_admin`).
   - Функции:
     - список дегустаций;
     - создание/редактирование дегустации, образцов, параметров;
     - просмотр статуса участников (закончил/не закончил);
     - экспорт оценок в CSV.

5. **Подготовка к DataLens**
   - Документация по таблицам и полям для BI:
     - какие таблицы подключать,
     - как при необходимости раскладывать `ratings.data` по параметрам.
   - Опционально: SQL‑представления для упрощения работы в BI.

6. **Шлифовка инфраструктуры**
   - Разделение конфигов dev/prod.
   - Базовое логирование и обработка ошибок.
   - Обновление инструкций по деплою.

**Результаты:**

- Страницы отчётов для участников с сравнением с группой и текстовым профилем.
- Админ‑панель для управления дегустациями и выгрузки данных.
- Документация по подключению БД к BI‑инструментам (DataLens).

---

## 5. Окружения и конфигурация

### Development

- Локальная машина (macOS).
- Инструменты:
  - Node.js (LTS),
  - Docker Desktop,
  - VS Code / другой редактор.
- Сервисы:
  - `docker-compose.dev.yml`:
    - `db` (Postgres, порт 5432).
- Бэкенд:
  - `.env.local` с переменными `DATABASE_URL`, `TELEGRAM_BOT_TOKEN` и др.
- Фронтенд:
  - dev‑сервер Vite (по умолчанию порт 5173).

### Production

- Управляемый инстанс PostgreSQL (host, port, DB name, user, password).
- Хостинг‑платформа, запускающая Docker‑контейнер приложения:
  - образ собирается из Dockerfile в репозитории.
- Env‑переменные:
  - `DATABASE_URL`
  - `TELEGRAM_BOT_TOKEN`
  - `APP_BASE_URL`
  - и др.
- Автодеплой из Git‑репо (по push в main/master).

---

## 6. Следующие шаги после MVP

- Расширение модели оценок (текстовые отзывы, дополнительные параметры).
- Более продвинутые рекомендации по чаю на основе профилей пользователей.
- Реальные дашборды в DataLens.
- Опционально — web3/crypto‑расширения (on‑chain‑подтверждения дегустаций и т.п.), если это станет актуально.
