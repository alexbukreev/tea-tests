# Платформа дегустации чая — Технический план (MVP, 3 спринта)

## 0. Обзор

- Домен: коллективные дегустации чая.
- Фронтенд: React + Vite + shadcn/ui.
- Бэкенд: Node.js (Express или лёгкий NestJS).
- База данных: PostgreSQL.
- Аутентификация: через Telegram, доступ к вебу по токенизированным ссылкам.
- Инфраструктура:
  - Dev: локальный Postgres в Docker, фронт и бэк запускаются нативно.
  - Prod: одно Docker-приложение (API + статический фронтенд) на хостинге + управляемый PostgreSQL.

Работа делится на три спринта по две недели. Этот документ описывает целевую архитектуру и технический объём работ по спринтам.

---

## 1. Архитектура

### 1.1. Компоненты

- **Frontend-приложение**
  - React + Vite.
  - UI-кит: shadcn/ui.
  - Работает с REST API.
  - Основные сценарии:
    - форма оценок с лучевой диаграммой;
    - просмотр результата участника;
    - минимальный админ-интерфейс.

- **Backend API**
  - Node.js-приложение (Express или NestJS).
  - Ответственность:
    - обработка вебхуков/запросов от Telegram-бота;
    - регистрация и идентификация пользователей по Telegram;
    - генерация и разрешение auth-ссылок;
    - CRUD для дегустаций, образцов чая, оценок;
    - агрегации для отчётов.

- **База данных**
  - PostgreSQL 16/18.
  - В продакшене — управляемый инстанс.
  - В разработке — контейнер в Docker.

- **Telegram-бот**
  - Бот на базе `node-telegram-bot-api`, Telegraf или аналогичной библиотеки.
  - Общается только с backend API; вся бизнес-логика на бэке.

- **Деплой**
  - Dockerfile для бэкенда (отдаёт собранный фронтенд как статику).
  - docker-compose:
    - `docker-compose.dev.yml` — локальная разработка (только БД).
    - `docker-compose.yml` — продакшен (приложение; БД — отдельный управляемый сервис).
  - CI/CD или автодеплой с Git-репозитория на платформе хостинга.

---

## 2. Модель данных (MVP)

### 2.1. Таблицы

Минимальная концептуальная схема:

- **users**
  - `id` (UUID / serial PK)
  - `telegram_id` (bigint, уникальный)
  - `telegram_username` (text, nullable)
  - `telegram_full_name` (text)
  - `is_admin` (boolean, default false)
  - `created_at` (timestamp)

- **tastings**
  - `id` (UUID PK)
  - `title` (text)
  - `description` (text, nullable)
  - `scheduled_at` (timestamp, nullable)
  - `created_at` (timestamp)
  - `created_by` (FK → users.id, nullable)

- **tea_samples**
  - `id` (UUID PK)
  - `tasting_id` (FK → tastings.id)
  - `name` (text)
  - `notes` (text, nullable)
  - `order_index` (int) — порядок в дегустации

- **rating_dimensions**
  - `id` (UUID PK)
  - `tasting_id` (FK → tastings.id)
  - `code` (text) — например, `aroma`, `sweetness`
  - `label` (text) — человекочитаемое имя параметра
  - `min_value` (int, default 0)
  - `max_value` (int, default 10)

- **ratings**
  - `id` (UUID PK)
  - `user_id` (FK → users.id)
  - `tea_sample_id` (FK → tea_samples.id)
  - `created_at` (timestamp)
  - `data` (jsonb) — словарь: код параметра → значение (int)

- **auth_links**
  - `id` (UUID или случайный токен PK)
  - `user_id` (FK → users.id)
  - `purpose` (enum: `rating_page`, `result_page`, `admin_panel`, ...)
  - `context` (jsonb) — например, `{ "tasting_id": "...", "tea_sample_id": "..." }`
  - `expires_at` (timestamp)
  - `used_at` (timestamp, nullable)

Такая схема удобна для BI и аналитики (особенно `ratings.data` с кодами параметров) и достаточно гибкая для будущих изменений.

---

## 3. Аутентификация и пользователи

### 3.1. Регистрация пользователя через Telegram

- Бот получает `/start` или любую команду.
- Бот отправляет POST на бэкенд:

  `POST /api/telegram/register`

  ```json
  {
    "telegram_id": 123456789,
    "username": "user",
    "full_name": "Tea Lover"
  }
  ```

- Логика бэкенда:
  - ищет пользователя по `telegram_id`;
  - если нет — создаёт;
  - обновляет username/full_name при необходимости;
  - возвращает `{ "status": "ok" }`.

### 3.2. Auth-ссылки (одноразовые / краткоживущие)

- Эндпоинт бэкенда:

  `POST /api/auth/link`

  Пример тела (для страницы оценок):

  ```json
  {
    "telegram_id": 123456789,
    "purpose": "rating_page",
    "context": {
      "tasting_id": "UUID",
      "tea_sample_id": "UUID"
    }
  }
  ```

- Бэкенд:
  - находит пользователя по `telegram_id`;
  - создаёт запись в `auth_links` с `expires_at` (например, +30 минут);
  - возвращает URL вида `https://app.example/rate?token=<auth_link_id>`.

- Бот отправляет эту ссылку пользователю.

### 3.3. Разрешение auth-ссылки

- Фронтенд:
  - читает `token` из query-строки;
  - вызывает `GET /api/auth/resolve?token=<token>`.

- Бэкенд:
  - проверяет токен:
    - существует,
    - не истёк,
    - при необходимости — что `purpose` соответствует ожидаемому типу;
  - опционально выставляет `used_at` (если нужна строгая одноразовость);
  - возвращает:

  ```json
  {
    "user": {
      "id": "UUID",
      "name": "Tea Lover"
    },
    "purpose": "rating_page",
    "context": {
      "tasting_id": "UUID",
      "tea_sample_id": "UUID"
    }
  }
  ```

- Фронтенд:
  - сохраняет минимальное состояние сессии (userId, tastingId, teaSampleId) в памяти / session storage;
  - использует их для дальнейших запросов к API.

### 3.4. Доступ администратора

- Флаг `users.is_admin = true` помечает админов.
- Сценарий для админа:
  - админ отправляет в бота `/admin`;
  - бот запрашивает auth-ссылку с `purpose = "admin_panel"`;
  - бэкенд проверяет, что пользователь является админом, создаёт ссылку;
  - админ открывает `https://app.example/admin?token=...`;
  - фронтенд вызывает `/api/auth/resolve` и проверяет `purpose === "admin_panel"`.

---

## 4. Спринты (техническая разбивка)

### Спринт 1 — Интерфейс оценки и демо с лучевой диаграммой

**Цели:**

- Настроить фронтенд-проект.
- Реализовать мобильный интерфейс оценок с лучевой диаграммой и ~18 параметрами.
- Подготовить демо, которое можно показать на телефоне, даже без Telegram и бэкенда.

**Задачи:**

1. **Репозиторий и инструменты**
   - Создать репозиторий (или монорепо) с фронтендом и заготовкой под бэкенд.
   - Настроить Vite + React + TypeScript.
   - Подключить shadcn/ui.

2. **Базовый фронтенд**
   - Структура проекта, базовый layout.
   - Главная страница/модуль дегустации.

3. **Страница оценки с лучевой диаграммой**
   - Макет и верстка интерфейса под мобильные устройства:
     - диаграмма закреплена в верхней части экрана,
     - под диаграммой — список параметров (около 18) с ползунками.
   - Реализация управления параметрами:
     - значения хранятся локально (в состоянии фронтенда),
     - при изменении ползунка диаграмма обновляется.

4. **Поведение диаграммы**
   - Базовый вариант:
     - диаграмма не интерактивна, только отражает текущее состояние параметров.
   - Дополнительно (при наличии ресурсов):
     - возможность изменения значения параметра через перетаскивание точки на диаграмме (интерактивная лучевая диаграмма).

5. **Демо-данные**
   - Жёстко заданный набор параметров и один «виртуальный» образец чая.
   - Отдельный режим для демонстрации (без реальной авторизации и сохранения).

**Результаты:**

- Живой интерфейс для дегустации, который можно открыть на телефоне:
  - ползунки для параметров,
  - обновляемая лучевая диаграмма.
- Репозиторий с настроенным фронтенд-проектом и заготовкой под бэкенд.

---

### Спринт 2 — Бэкенд, БД, Telegram, сохранение оценок

**Цели:**

- Реализовать ядро бэкенда и базу данных.
- Интегрировать Telegram-бота.
- Подключить интерфейс из Спринта 1 к реальному API и постоянному хранилищу.

**Задачи:**

1. **Каркас бэкенда**
   - Приложение на Express или NestJS.
   - Базовые роуты:
     - `GET /health` — проверка живости.
   - Загрузчик конфигурации (env-переменные для DB URL, Telegram token и т.п.).

2. **База данных и миграции**
   - Выбор ORM/инструмента миграций (Prisma / Knex / TypeORM).
   - Реализация миграций для таблиц:
     - `users`,
     - `tastings`,
     - `tea_samples`,
     - `rating_dimensions`,
     - `ratings`,
     - `auth_links`.

3. **Интеграция с Telegram**
   - Создание и настройка бота.
   - Эндпоинт `/api/telegram/register`:
     - создание/поиск пользователя по `telegram_id`.
   - Простая логика бота:
     - `/start` → регистрация пользователя;
     - выдача ссылки на дегустацию/образец через auth-ссылку.

4. **Auth-ссылки и идентификация**
   - Эндпоинты:
     - `POST /api/auth/link` — создание auth-ссылок;
     - `GET /api/auth/resolve` — проверка и разрешение токена.
   - Связь с фронтендом:
     - фронт читает `token` из URL, вызывает `/api/auth/resolve`, получает контекст (пользователь, дегустация, образец).

5. **API для оценок**
   - Эндпоинты:
     - `GET /api/tastings/:id` — получение дегустации, образцов и параметров;
     - `POST /api/ratings` — сохранение/обновление оценок пользователя по образцу.

6. **Подключение фронтенда к API**
   - Страница оценок:
     - вместо жёстко заданных данных — загрузка параметров из API;
     - отправка оценок через `POST /api/ratings`.
   - Проверка полного цикла:
     - пользователь регистрируется через Telegram,
     - получает ссылку,
     - заполняет форму,
     - данные оказываются в БД.

7. **Dev/Prod инфраструктура**
   - `docker-compose.dev.yml`:
     - сервис `db` (Postgres).
   - Подготовка Dockerfile для бэкенда (без финального прод-деплоя или с базовым деплоем по возможности).

**Результаты:**

- Рабочий бэкенд с БД и интеграцией с Telegram.
- Интерфейс оценок из Спринта 1 подключён к реальному API.
- Полный рабочий цикл дегустации с сохранением данных в БД.

---

### Спринт 3 — Отчёты для участников, админ-панель, интеграция с Airtable

**Цели:**

- Реализовать отчёты для участника (профиль + сравнение с группой).
- Подключить Airtable как внешний источник/редактор справочников (дегустации, образцы чая, тексты).
- Сделать минимальную админ-панель для мониторинга дегустаций и рассылки результатов.

**Задачи:**

1. **Агрегации и аналитические эндпоинты**
   - Эндпоинты:
     - `GET /api/tastings/:id/summary`
       - средние значения по параметрам и образцам;
     - `GET /api/users/:id/tastings/:tastingId/profile`
       - оценки пользователя + средние по группе.
   - Логика:
     - вычисление базового текстового профиля пользователя по его предпочтениям (простые правила/шаблоны).

2. **Страница отчёта участника**
   - Frontend-маршрут для страницы результата.
   - Аутентификация через auth-ссылку (`purpose = "result_page"`).
   - UI:
     - лучевая диаграмма: пользователь vs группа;
     - текстовое описание профиля;
     - при желании — список чаёв с краткими комментариями.

3. **Интеграция с Airtable (read-only для MVP)**
   - Дизайн структуры таблиц в Airtable:
     - `Tastings` (id/slug, title, date, description, is_active и т.п.);
     - `TeaSamples` (id/slug, tasting_ref, name, notes, order_index);
     - опционально — таблица с текстовыми шаблонами профилей.
   - Создание минимального клиента для Airtable в бэкенде:
     - конфиг: base ID, таблицы, API token через env (`AIRTABLE_API_KEY`, `AIRTABLE_BASE_ID`);
     - функции:
       - `fetchTastings()`,
       - `fetchTeaSamples(tastingId)`.
   - Вариант интеграции для MVP:
     - дегустации и образцы загружаются из Airtable (read-only),
     - пользователи и оценки по-прежнему хранятся в PostgreSQL.
   - Кэширование (минимальное):
     - либо простой in-memory кэш с TTL (например, 60–300 сек),
     - либо ручное обновление (эндпоинт admin `POST /api/admin/sync-airtable`).

4. **Админ-панель (MVP)**
   - Frontend-маршрут `/admin`.
   - Аутентификация через auth-ссылку (`purpose = "admin_panel"`, проверка `user.is_admin`).
   - Функции:
     - список дегустаций (структура из Airtable + статистика из Postgres);
     - просмотр количества участников и статуса заполнения;
     - ручной запуск рассылки отчётов:
       - создание auth-ссылок `result_page` для всех участников,
       - вызов логики бота для отправки ссылок.

5. **Инфраструктура и конфигурация под Airtable**
   - Добавить env-переменные:
     - `AIRTABLE_API_KEY`,
     - `AIRTABLE_BASE_ID`,
     - `AIRTABLE_TASTINGS_TABLE`,
     - `AIRTABLE_SAMPLES_TABLE`.
   - Обновить документацию по конфигурации (TECH_PLAN_RU, README).

**Результаты:**

- Страница отчёта участника с сравнением с группой и текстовым профилем.
- Airtable используется как внешний источник данных для дегустаций и образцов чая:
  - заказчик может сам редактировать списки и описания в Airtable;
  - бэкенд читает эти данные через API.
- Админ-панель позволяет контролировать ход дегустаций и запускать рассылку результатов.
